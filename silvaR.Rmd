---
title: "silva"
output: html_notebook
---
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

# Load the package
library(metagenomeSeq)

# Load example data
data("HC", package="metagenomeSeq")

# Create a count data object
#countData <- as.matrix(otuTable(HC))
count_data <- read.csv("C:\\Users\\hibaorsud\\Desktop\\all taxa\\otu_table-silva.csv", row.names = 1)
sample_data <-read.csv("C:\\Users\\hibaorsud\\Desktop\\all taxa\\meta_data.csv", row.names = 1)
# Convert data frames to the appropriate format
count_matrix <- as.matrix(count_data)
# Reorder columns of count_matrix to match rownames of sample_data
count_matrix <- count_matrix[, rownames(sample_data)]
# Check column names of count matrix
colnames(count_matrix)

# Check row names of sample data
rownames(sample_data)
# Check if names match
if (!identical(colnames(count_matrix), rownames(sample_data))) {
    stop("Sample names in count matrix and sample metadata do not match")
}
# Filter low abundance features
min_count <- 5
min_samples <- 3
keep_features <- rowSums(count_matrix >= min_count) >= min_samples
count_matrix <- count_matrix[keep_features, ]
# Create AnnotatedDataFrame for sample metadata
phenoData <- AnnotatedDataFrame(sample_data)
# Create a MRexperiment object
obj <- newMRexperiment(count_matrix, phenoData = phenoData)
# Normalize the data
obj <- cumNorm(obj, p = cumNormStatFast(obj))
# Extract normalized counts
norm_counts <- MRcounts(obj, norm = TRUE)
# Check column names in the sample metadata
print(colnames(pData(obj)))
# Replace 'Event.status' with the actual column name in your sample data
actual_covariate_name <- "Baseline.and.follow.ups"  # Replace with your actual covariate column name
# Construct the model using the correct column name
model <- model.matrix(~ Baseline.and.follow.ups, data = pData(obj))
# Check the design matrix
head(model)
# Fit the linear model using limma
fit <- lmFit(norm_counts, model)
# Manually create a contrast matrix
contrast_matrix <- matrix(0, nrow = ncol(model), ncol = 1)
rownames(contrast_matrix) <- colnames(model)
contrast_matrix[actual_covariate_name, ] <- 1
# Apply the contrasts to the fit object
fit2 <- contrasts.fit(fit, contrast_matrix)
# Compute statistics
fit2 <- eBayes(fit2)
## Extract the top differentially abundant features(10)
top_results <- topTable(fit2, adjust = "fdr", sort.by = "P", number = 230)
# View the results
print(top_results)
write.csv(top_results, file = "metagenomeseq.BF.silva", row.names = TRUE)
## Create a bar plot
library(ggplot2)
## Create a bar plot
----
# Assuming `top_results` is your data frame and `logFC` is the column with log fold changes
ggplot(top_results, aes(x = reorder(rownames(top_results), -logFC), y = logFC, fill = ifelse(logFC > 0, "B", "F"))) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(x = "Features", y = "Log Fold Change", title = "Top Differentially Abundant Features") +
  theme_minimal() +
  scale_fill_manual(values = c("B" = "cyan3", "F" = "coral1"))

# Create a volcano plot
ggplot(top_results, aes(x = logFC, y = -log10(P.Value))) +
    geom_point(alpha = 0.5) +
    geom_vline(xintercept = c(-1, 1), linetype = "dashed", color = "red") +
    geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red") +
    labs(x = "Log Fold Change", y = "-log10(p-value)", title = "Volcano Plot") +
    theme_minimal()
# Create a heatmap of normalized counts for top features
library(pheatmap)
top_features <- rownames(top_results)
norm_counts_top <- norm_counts[top_features, ]
my_palette <- colorRampPalette(c("tomato", "white", "springgreen3"))(n = 100)
pheatmap(norm_counts_top, 
         scale = "row", 
         clustering_distance_rows = "correlation", 
         clustering_distance_cols = "correlation", 
         show_rownames = TRUE, 
         show_colnames = TRUE, 
         main = "Heatmap of Top Differentially Abundant Features",
         color=my_palette)







\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
plot(cars)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.

taxa <- assignTaxonomy(my_otus, "C:\\Users\\hibaorsud\\Downloads\\silva_nr_v138_train_set.fa.gz", multithread=TRUE)
taxa.print <- taxa # Removing sequence rownames for display only
head(taxa.print)

library(Biostrings)
my_otus <- ("C:\\Users\\hibaorsud\\Desktop\\HIBA Desktop\\PR2\\OTU_final.fasta")
silva <- ("C:\Users\hibaorsud\Desktop\HIBA Desktop\DOWNLOADS\silva.nr_v138_1")
library(dada2)
taxa <- assignTaxonomy(my_otus,"C:\\Users\\hibaorsud\\Desktop\\HIBA Desktop\\DOWNLOADS\\silva_nr_v138_train_set.fa.gz", multithread=TRUE)
taxa.print <- taxa # Removing sequence rownames for display only
head(taxa.print)

library(phyloseq)
taxa <- "C:\\Users\\hibaorsud\\Desktop\\all taxa\\taxaSilva_table.csv"
otu_table<- ""
taxa_data <- read.csv("taxa.csv", row.names = 1)
physeq <- phyloseq(otu_table(taxa, taxa_are.rows = TRUE))


if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("BiocStyle")
library(BiocStyle)
a
install.packages("survival")
library(dada2)
BiocManager::install("phangorn")
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
otus <- "C:\\Users\\hibaorsud\\Desktop\\all taxa\\OTU_final.fasta"

seqs <- getSequences(otus)
names(seqs) <- seqs # This propagates to the tip labels of the tree
alignment <- AlignSeqs(DNAStringSet(seqs), anchor=NA,verbose=FALSE)
library("knitr")
library("BiocStyle")
library(dada2)
library(BiocStyle)
library(knitr)
library(DECIPHER)
library(phangorn)
phangAlign <- phyDat(as(alignment, "matrix"), type="DNA")
dm <- dist.ml(phangAlign)
treeNJ <- NJ(dm) # Note, tip order != sequence order
fit = pml(treeNJ, data=phangAlign)
fitGTR <- update(fit, k=4, inv=0.2)
fitGTR <- optim.pml(fitGTR, model="GTR", optInv=TRUE, optGamma=TRUE,
        rearrangement = "stochastic", control = pml.control(trace = 0))
detach("package:phangorn", unload=TRUE)
-----
print(dm)
print(treeNJ)
plot(treeNJ)
treeNJ <- root(treeNJ, outgroup = 3)  # Replace '1' with an appropriate outgroup
fit <- pml(treeNJ, data=phangAlign)
---------
/////////////
>>>>>>>>>>>>>>>>>>>
# Load necessary libraries
library(DECIPHER)
library(phangorn)

# Example sequence data for illustration
seqs <- getSequences(otus)

# Align sequences (assuming this step is already completed in your workflow)
alignment <- AlignSeqs(DNAStringSet(seqs), anchor=NA, verbose=FALSE)

# Convert alignment to phyDat object
phangAlign <- phyDat(as(alignment, "matrix"), type="DNA")
print(phangAlign)

# Calculate distance matrix
dm <- dist.ml(phangAlign)
print(dm)

# Construct neighbor-joining tree
treeNJ <- NJ(dm)
print(treeNJ)
plot(treeNJ)
plot(treeNJ, cex =1.0)

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#png("tree-seq_plot.png", width = 10, height = 12, units = "in", res = 300)
# Ensure the tree is rooted
treeNJ <- root(treeNJ, outgroup = 3)  # Replace '1' with an appropriate outgroup
plot(treeNJ)
tree_df <- as.data.frame(treeNJ$edge)
write.csv(tree_df, "treeNJ.csv", row.names = TRUE)
write.tree(treeNJ, file = "treeNJ.tre")


# Create pml object
fit <- pml(treeNJ, data=phangAlign)
print(fit)

# Optimize the phylogenetic model with GTR
fitGTR <- update(fit, k=4, inv=0.2)
fitGTR <- optim.pml(fitGTR, model="GTR", optInv=TRUE, optGamma=TRUE,
                    rearrangement="stochastic", control=pml.control(trace=0))

# Print the optimized model results
print(fitGTR)

# Detach the phangorn package if needed
detach("package:phangorn", unload=TRUE)
//////////////////
library(phyloseq)
# Read the sample data from CSV
samdf <- read.csv("C:\\Users\\hibaorsud\\Desktop\\all taxa\\meta_data.csv", row.names = 1)

# Read the OTU table from CSV
otutable <- read.csv("C:\\Users\\hibaorsud\\Desktop\\all taxa\\otu_table_tgi.csv", row.names = 1)

# Read the tax table from CSV (if you have it)
taxTab <- read.csv("C:\\Users\\hibaorsud\\Desktop\\all taxa\\taxa-silva.csv", row.names = 1)

# Print each component to ensure they are correctly formatted
print(sample_data_obj)
print(otu_table_obj)
print(tax_table_obj)
print(phy_tree_obj)

# Convert to phyloseq components
# Assume these are your previously created objects
# OTU Table
otu_table_obj <- otu_table(as.matrix(read.csv("C:\\Users\\hibaorsud\\Desktop\\all taxa\\otu_table_tgi.csv", row.names = 1)), taxa_are_rows = FALSE)

# Sample Data
sample_data_obj <- sample_data(read.csv("C:\\Users\\hibaorsud\\Desktop\\all taxa\\meta_data.csv", row.names = 1))

# Tax Table
tax_table_obj <- tax_table(as.matrix(read.csv("C:\\Users\\hibaorsud\\Desktop\\all taxa\\taxa-silva.csv", row.names = 1)))

# Assuming you already have a phylogenetic tree created (fitGTR$tree)
phy_tree_obj <- phy_tree(fitGTR$tree)

# Ensure all components have the same row names
all_same <- identical(rownames(otu_table_obj), rownames(tax_table_obj)) && identical(rownames(otu_table_obj), rownames(sample_data_obj))

if (all_same) {
  ps <- phyloseq(otu_table_obj, sample_data_obj, tax_table_obj, phy_tree_obj)
  print("Phyloseq object created successfully.")
} else {
  stop("The names in the OTU table, tax table, and sample data do not match.")
}
# Create phyloseq object
  ps <- phyloseq(otu_table_obj,sample_data_obj, tax_table_obj, phy_tree_obj)
taxa_names(tax_table_object)
................
ps <- phyloseq(otu_table(otu_table_obj, taxa_are_rows=FALSE), 
               sample_data(samdf), 
               tax_table(tax_table_obj),phy_tree_obj)


otu_names <- rownames(otu_table_obj)
tax_names <- rownames(tax_table_obj)
sample_names <- rownames(sample_data_obj)

print(otu_names)
print(tax_names)
print(sample_names)

# Ensure row names are consistent across all components
consistent_names <- Reduce(intersect, list(otu_names, tax_names, sample_names))
# Print consistent names
print("Consistent Names:")
print(consistent_names)
# Subset each component to have only the consistent names
otu_table_obj <- otu_table_obj[consistent_names, ]
tax_table_obj <- tax_table_obj[consistent_names, ]
sample_data_obj <- sample_data_obj[consistent_names, ]
................
# Check if the object is valid
  if (validObject(ps)) {
    print("The phyloseq object is valid.")
  } else {
    print("The phyloseq object is not valid.")
  }
} 


print(rownames(otu_table_obj))
print(rownames(tax_table_obj))
print(rownames(sample_data_obj))


# Suppose OTU names in otu_table_obj and tax_table_obj do not match
# Set them to the same value
rownames(otu_table_obj) <- rownames(tax_table_obj) <- rownames(sample_data_obj)

# Print the phyloseq object
print(ps)





