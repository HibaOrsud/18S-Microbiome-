---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
plot(cars)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.



# Load example data
data("HC", package="metagenomeSeq")
# Load the package
library(metagenomeSeq)

# Create a count data object
#countData <- as.matrix(otuTable(HC))
count_data <- read.csv("C:\\Users\\hibaorsud\\Desktop\\New\\R-inputs\\new-count-table.sp-pr2-B.csv", row.names = 1)
sample_data <-read.csv("C:\\Users\\hibaorsud\\Desktop\\New\\R-inputs\\new-meta_data.csv", row.names = 1)
# Convert data frames to the appropriate format
count_matrix <- as.matrix(count_data)
# Reorder columns of count_matrix to match rownames of sample_data
count_matrix <- count_matrix[, rownames(sample_data)]
# Check column names of count matrix
colnames(count_matrix)

# Check row names of sample data
rownames(sample_data)
# Check if names match
if (!identical(colnames(count_matrix), rownames(sample_data))) {
    stop("Sample names in count matrix and sample metadata do not match")
}
# Filter low abundance features
min_count <- 5
min_samples <- 3
keep_features <- rowSums(count_matrix >= min_count) >= min_samples
count_matrix <- count_matrix[keep_features, ]
# Create AnnotatedDataFrame for sample metadata
phenoData <- AnnotatedDataFrame(sample_data)
# Create a MRexperiment object
obj <- newMRexperiment(count_matrix, phenoData = phenoData)
# Normalize the data
obj <- cumNorm(obj, p = cumNormStatFast(obj))
# Extract normalized counts
norm_counts <- MRcounts(obj, norm = TRUE)
# Check column names in the sample metadata
print(colnames(pData(obj)))
# Replace 'Event.status' with the actual column name in your sample data
actual_covariate_name <- "Event.status"  # Replace with your actual covariate column name
# Construct the model using the correct column name
model <- model.matrix(~ Event.status, data = pData(obj))
# Check the design matrix
head(model)
# Fit the linear model using limma
fit <- lmFit(norm_counts, model)
# Manually create a contrast matrix
contrast_matrix <- matrix(0, nrow = ncol(model), ncol = 1)
rownames(contrast_matrix) <- colnames(model)
contrast_matrix[actual_covariate_name, ] <- 1
# Apply the contrasts to the fit object
fit2 <- contrasts.fit(fit, contrast_matrix)
# Compute statistics
fit2 <- eBayes(fit2)
## Extract the top differentially abundant features(10)
top_results <- topTable(fit2, adjust = "fdr", sort.by = "P", number = 50)
write.csv(top_results, file = "metagenomeseq.its-cncr.t", row.names = TRUE)
# View the results
print(top_results)
library(ggplot2)
## Create a bar plot
----
# Assuming `top_results` is your data frame and `logFC` is the column with log fold changes
ggplot(top_results, aes(x = reorder(rownames(top_results), -logFC), y = logFC, fill = ifelse(logFC > 0, "Non-responder" , "Responder"))) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(x = "Features", y = "Log Fold Change", title = "Top Differentially Abundant Features") +
  theme_minimal() +
  scale_fill_manual(values = c("Responder" = "cyan3", "Non-responder" = "coral1"))

----
ggplot(top_results, aes(x = reorder(rownames(top_results), -logFC), y = logFC)) +
    geom_bar(stat = "identity", fill = "steelblue") +
    coord_flip() +
    labs(x = "Features", y = "Log Fold Change", title = "Top Differentially Abundant Features") +
    theme_minimal()
 
 ggplot(top_results, aes(x = reorder(rownames(top_results), -logFC), y = logFC, fill = ifelse(logFC > 0, "with Immunotherapy", "without Immunotherapy"))) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(x = "Features", y = "Log Fold Change", title = "Top Differentially Abundant Features") +
  theme_minimal()
 
 
 #add condition label
  ggplot(top_results, aes(x = reorder(rownames(top_results), -logFC), y = logFC, fill = ifelse(logFC > 0, "steelblue", "red"))) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = ifelse(logFC > 0, "R", "NR")), vjust = -0.5, hjust = 0.5, color = "black", size = 3) + 
  coord_flip() +
  labs(x = "Features", y = "Log Fold Change", title = "Top Differentially Abundant Features") +
  theme_minimal()
  
  
# Create a volcano plot
ggplot(top_results, aes(x = logFC, y = -log10(P.Value))) +
    geom_point(alpha = 0.5) +
    geom_vline(xintercept = c(-1, 1), linetype = "dashed", color = "red") +
    geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red") +
    labs(x = "Log Fold Change", y = "-log10(p-value)", title = "Volcano Plot") +
    theme_minimal()
# Create a heatmap of normalized counts for top features
library(pheatmap)
top_features <- rownames(top_results)
norm_counts_top <- norm_counts[top_features, ]
my_palette <- colorRampPalette(c("steelblue", "lemonchiffon", "brown2"))(n = 100)
pheatmap(norm_counts_top, 
         scale = "row", 
         clustering_distance_rows = "correlation", 
         clustering_distance_cols = "correlation", 
         show_rownames = TRUE, 
         show_colnames = TRUE, 
         main = "Heatmap of Top Differentially Abundant Features",
          color = my_palette)



write.csv(top_results, file = "metagenomeseq.R-NR.PR2", row.names = TRUE)

-------------------------------------------------

library(pheatmap)

# Create a vector indicating responder and nonresponder for each column
# Replace with the actual mapping of your samples to responder/nonresponder status
# Example data for annotation_col
annotation_col <- data.frame(
  Cancer.types = rep(c("GI", "Non-GI"), length.out = 31)  # Adjust to your actual data
)
rownames(annotation_col) <- colnames(norm_counts_top)

dim(annotation_col)  # Should return 38 1
length(colnames(norm_counts_top))  # Should return 38
all(rownames(annotation_col) == colnames(norm_counts_top))  # Should return TRUE

# Define annotation colors
ann_colors <- list(
  Cancer.types = c('GI' = "cyan3", `Non-GI` = "coral1")  # Fix naming with backticks
)

# Generate the heatmap
pheatmap(norm_counts_top, 
         scale = "row", 
         clustering_distance_rows = "correlation", 
         clustering_distance_cols = "correlation", 
         show_rownames = TRUE, 
         show_colnames = TRUE, 
         main = "Heatmap of Top Differentially Abundant Features",
         annotation_col = annotation_col,  # Add annotations
         annotation_colors = ann_colors,  # Add color mapping for annotations
         color = my_palette)

-------------

